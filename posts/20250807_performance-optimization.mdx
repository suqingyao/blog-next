---
id: 20250807_performance-optimization
title: å‰ç«¯æ€§èƒ½ä¼˜åŒ–å®æˆ˜æŒ‡å—
createdTime: 2025-08-07 00:00:22
published: true
tags: ['æ€§èƒ½ä¼˜åŒ–', 'Vite', 'Webpack', 'HTTPç¼“å­˜', 'æ„å»ºä¼˜åŒ–']
description: 'æ·±å…¥æ¢è®¨å‰ç«¯æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œæ¶µç›–Viteå’ŒWebpackæ„å»ºä¼˜åŒ–ã€HTTPç¼“å­˜ç­–ç•¥ã€ä»£ç åˆ†å‰²ç­‰å®æˆ˜æŠ€å·§'
---

æ€§èƒ½ä¼˜åŒ–æ˜¯å‰ç«¯å¼€å‘ä¸­çš„é‡è¦ç¯èŠ‚ï¼Œç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒå’Œä¸šåŠ¡æŒ‡æ ‡ã€‚æœ¬æ–‡å°†ä»æ„å»ºä¼˜åŒ–ã€HTTPç¼“å­˜ã€ä»£ç åˆ†å‰²ç­‰å¤šä¸ªç»´åº¦ï¼Œè¯¦ç»†ä»‹ç»å‰ç«¯æ€§èƒ½ä¼˜åŒ–çš„å®æˆ˜ç­–ç•¥ã€‚

## æ€§èƒ½ä¼˜åŒ–åˆ†ææ¡†æ¶

### æ€§èƒ½æŒ‡æ ‡ä½“ç³»

```mermaid
mindmap
  root((æ€§èƒ½æŒ‡æ ‡))
    åŠ è½½æ€§èƒ½
      FCP (é¦–æ¬¡å†…å®¹ç»˜åˆ¶)
      LCP (æœ€å¤§å†…å®¹ç»˜åˆ¶)
      FID (é¦–æ¬¡è¾“å…¥å»¶è¿Ÿ)
      CLS (ç´¯ç§¯å¸ƒå±€åç§»)
    è¿è¡Œæ—¶æ€§èƒ½
      JavaScriptæ‰§è¡Œæ—¶é—´
      å†…å­˜ä½¿ç”¨æƒ…å†µ
      CPUä½¿ç”¨ç‡
      å¸§ç‡(FPS)
    ç½‘ç»œæ€§èƒ½
      DNSè§£ææ—¶é—´
      TCPè¿æ¥æ—¶é—´
      HTTPè¯·æ±‚æ—¶é—´
      èµ„æºä¸‹è½½æ—¶é—´
    ç”¨æˆ·ä½“éªŒ
      é¡µé¢å¯äº¤äº’æ—¶é—´
      é¦–å±æ¸²æŸ“æ—¶é—´
      ç™½å±æ—¶é—´
      é¡µé¢å®Œå…¨åŠ è½½æ—¶é—´
```

### æ€§èƒ½åˆ†æå·¥å…·

```javascript
/**
 * æ€§èƒ½ç›‘æ§å·¥å…·ç±»
 * ç”¨äºæ”¶é›†å’Œåˆ†æé¡µé¢æ€§èƒ½æ•°æ®
 */
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.observers = [];
  }

  /**
   * åˆå§‹åŒ–æ€§èƒ½ç›‘æ§
   */
  init() {
    this.observeWebVitals();
    this.observeResourceTiming();
    this.observeNavigationTiming();
  }

  /**
   * ç›‘æ§Web VitalsæŒ‡æ ‡
   */
  observeWebVitals() {
    // ç›‘æ§LCP (Largest Contentful Paint)
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.metrics.lcp = lastEntry.startTime;
      console.log('LCP:', lastEntry.startTime);
    }).observe({ entryTypes: ['largest-contentful-paint'] });

    // ç›‘æ§FID (First Input Delay)
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      entries.forEach((entry) => {
        this.metrics.fid = entry.processingStart - entry.startTime;
        console.log('FID:', entry.processingStart - entry.startTime);
      });
    }).observe({ entryTypes: ['first-input'] });

    // ç›‘æ§CLS (Cumulative Layout Shift)
    let clsValue = 0;
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
      this.metrics.cls = clsValue;
      console.log('CLS:', clsValue);
    }).observe({ entryTypes: ['layout-shift'] });
  }

  /**
   * ç›‘æ§èµ„æºåŠ è½½æ—¶é—´
   */
  observeResourceTiming() {
    new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      entries.forEach((entry) => {
        const resourceTiming = {
          name: entry.name,
          duration: entry.duration,
          transferSize: entry.transferSize,
          encodedBodySize: entry.encodedBodySize,
          decodedBodySize: entry.decodedBodySize
        };
        console.log('Resource Timing:', resourceTiming);
      });
    }).observe({ entryTypes: ['resource'] });
  }

  /**
   * ç›‘æ§é¡µé¢å¯¼èˆªæ—¶é—´
   */
  observeNavigationTiming() {
    window.addEventListener('load', () => {
      const navigation = performance.getEntriesByType('navigation')[0];
      this.metrics.navigation = {
        dnsLookup: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcpConnect: navigation.connectEnd - navigation.connectStart,
        request: navigation.responseStart - navigation.requestStart,
        response: navigation.responseEnd - navigation.responseStart,
        domParse:
          navigation.domContentLoadedEventStart - navigation.responseEnd,
        domReady:
          navigation.domContentLoadedEventEnd -
          navigation.domContentLoadedEventStart,
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart
      };
      console.log('Navigation Timing:', this.metrics.navigation);
    });
  }

  /**
   * è·å–æ€§èƒ½æŠ¥å‘Š
   * @returns {Object} æ€§èƒ½æŒ‡æ ‡æ•°æ®
   */
  getReport() {
    return {
      ...this.metrics,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: location.href
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitor = new PerformanceMonitor();
monitor.init();
```

## Vite æ„å»ºä¼˜åŒ–

### Vite é…ç½®ä¼˜åŒ–

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';
import { visualizer } from 'rollup-plugin-visualizer';
import { compression } from 'vite-plugin-compression';
import legacy from '@vitejs/plugin-legacy';

/**
 * Vite ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–é…ç½®
 */
export default defineConfig(({ mode }) => {
  const isProduction = mode === 'production';

  return {
    plugins: [
      react(),

      // ä»£ç å‹ç¼©
      compression({
        algorithm: 'gzip',
        ext: '.gz',
        threshold: 1024,
        deleteOriginFile: false
      }),

      // Brotli å‹ç¼©
      compression({
        algorithm: 'brotliCompress',
        ext: '.br',
        threshold: 1024,
        deleteOriginFile: false
      }),

      // å…¼å®¹æ€§å¤„ç†
      legacy({
        targets: ['defaults', 'not IE 11']
      }),

      // æ‰“åŒ…åˆ†æ
      isProduction &&
        visualizer({
          filename: 'dist/stats.html',
          open: true,
          gzipSize: true,
          brotliSize: true
        })
    ].filter(Boolean),

    // æ„å»ºä¼˜åŒ–
    build: {
      // ä»£ç åˆ†å‰²
      rollupOptions: {
        output: {
          // æ‰‹åŠ¨åˆ†åŒ…
          manualChunks: {
            // ç¬¬ä¸‰æ–¹åº“å•ç‹¬æ‰“åŒ…
            vendor: ['react', 'react-dom'],
            // UIåº“å•ç‹¬æ‰“åŒ…
            ui: ['antd', '@ant-design/icons'],
            // å·¥å…·åº“å•ç‹¬æ‰“åŒ…
            utils: ['lodash', 'dayjs', 'axios']
          },
          // æ–‡ä»¶å‘½å
          chunkFileNames: 'js/[name]-[hash].js',
          entryFileNames: 'js/[name]-[hash].js',
          assetFileNames: (assetInfo) => {
            const info = assetInfo.name.split('.');
            const ext = info[info.length - 1];
            if (
              /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/i.test(assetInfo.name)
            ) {
              return `media/[name]-[hash].${ext}`;
            }
            if (
              /\.(png|jpe?g|gif|svg|webp|ico)(\?.*)?$/i.test(assetInfo.name)
            ) {
              return `images/[name]-[hash].${ext}`;
            }
            if (/\.(woff2?|eot|ttf|otf)(\?.*)?$/i.test(assetInfo.name)) {
              return `fonts/[name]-[hash].${ext}`;
            }
            return `assets/[name]-[hash].${ext}`;
          }
        }
      },

      // å‹ç¼©é…ç½®
      minify: 'terser',
      terserOptions: {
        compress: {
          drop_console: isProduction,
          drop_debugger: isProduction,
          pure_funcs: isProduction ? ['console.log'] : []
        }
      },

      // æ–‡ä»¶å¤§å°è­¦å‘Šé˜ˆå€¼
      chunkSizeWarningLimit: 1000,

      // å¯ç”¨ CSS ä»£ç åˆ†å‰²
      cssCodeSplit: true,

      // ç”Ÿæˆ source map
      sourcemap: !isProduction
    },

    // å¼€å‘æœåŠ¡å™¨ä¼˜åŒ–
    server: {
      // é¢„çƒ­å¸¸ç”¨æ–‡ä»¶
      warmup: {
        clientFiles: ['./src/components/**/*.tsx', './src/pages/**/*.tsx']
      }
    },

    // ä¾èµ–ä¼˜åŒ–
    optimizeDeps: {
      include: ['react', 'react-dom', 'antd', 'lodash', 'dayjs'],
      exclude: ['@vite/client', '@vite/env']
    },

    // è·¯å¾„åˆ«å
    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
        '@components': resolve(__dirname, 'src/components'),
        '@utils': resolve(__dirname, 'src/utils'),
        '@assets': resolve(__dirname, 'src/assets')
      }
    }
  };
});
```

### Vite æ’ä»¶ç”Ÿæ€

```javascript
// vite-plugins.js
import { defineConfig } from 'vite';

/**
 * Vite æ€§èƒ½ä¼˜åŒ–æ’ä»¶é…ç½®
 */
export const performancePlugins = [
  // 1. å›¾ç‰‡ä¼˜åŒ–æ’ä»¶
  {
    name: 'vite-plugin-imagemin',
    config: {
      gifsicle: { optimizationLevel: 7 },
      mozjpeg: { quality: 80 },
      pngquant: { quality: [0.65, 0.8] },
      svgo: {
        plugins: [
          { name: 'removeViewBox', active: false },
          { name: 'removeEmptyAttrs', active: false }
        ]
      }
    }
  },

  // 2. PWA æ’ä»¶
  {
    name: 'vite-plugin-pwa',
    config: {
      registerType: 'autoUpdate',
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\./,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'api-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 60 * 60 * 24 // 24å°æ—¶
              }
            }
          }
        ]
      }
    }
  },

  // 3. é¢„åŠ è½½æ’ä»¶
  {
    name: 'vite-plugin-preload',
    config: {
      files: [
        {
          entryMatch: /[a-zA-Z0-9]*\.(js)$/,
          attributes: {
            rel: 'modulepreload'
          }
        },
        {
          entryMatch: /[a-zA-Z0-9]*\.(css)$/,
          attributes: {
            rel: 'preload',
            as: 'style'
          }
        }
      ]
    }
  }
];
```

## Webpack æ„å»ºä¼˜åŒ–

### Webpack é…ç½®ä¼˜åŒ–

```javascript
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const CompressionPlugin = require('compression-webpack-plugin');
const WorkboxPlugin = require('workbox-webpack-plugin');

/**
 * Webpack ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–é…ç½®
 * @param {Object} env ç¯å¢ƒå˜é‡
 * @returns {Object} webpacké…ç½®
 */
module.exports = (env) => {
  const isProduction = env.NODE_ENV === 'production';
  const shouldAnalyze = env.ANALYZE === 'true';

  return {
    mode: isProduction ? 'production' : 'development',

    entry: {
      main: './src/index.js',
      // åˆ†ç¦»ç¬¬ä¸‰æ–¹åº“
      vendor: ['react', 'react-dom', 'lodash']
    },

    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: isProduction ? 'js/[name].[contenthash:8].js' : 'js/[name].js',
      chunkFilename: isProduction
        ? 'js/[name].[contenthash:8].chunk.js'
        : 'js/[name].chunk.js',
      assetModuleFilename: 'assets/[name].[contenthash:8][ext]',
      clean: true,
      publicPath: '/'
    },

    // ä¼˜åŒ–é…ç½®
    optimization: {
      minimize: isProduction,
      minimizer: [
        // JavaScript å‹ç¼©
        new TerserPlugin({
          terserOptions: {
            compress: {
              drop_console: isProduction,
              drop_debugger: isProduction,
              pure_funcs: ['console.log']
            },
            mangle: {
              safari10: true
            }
          },
          extractComments: false
        }),

        // CSS å‹ç¼©
        new CssMinimizerPlugin({
          minimizerOptions: {
            preset: [
              'default',
              {
                discardComments: { removeAll: true }
              }
            ]
          }
        })
      ],

      // ä»£ç åˆ†å‰²
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          // ç¬¬ä¸‰æ–¹åº“
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
            priority: 10
          },

          // React ç›¸å…³
          react: {
            test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
            name: 'react',
            chunks: 'all',
            priority: 20
          },

          // UI åº“
          ui: {
            test: /[\\/]node_modules[\\/](antd|@ant-design)[\\/]/,
            name: 'ui',
            chunks: 'all',
            priority: 15
          },

          // å…¬å…±ä»£ç 
          common: {
            name: 'common',
            minChunks: 2,
            chunks: 'all',
            priority: 5,
            reuseExistingChunk: true
          }
        }
      },

      // è¿è¡Œæ—¶ä»£ç åˆ†ç¦»
      runtimeChunk: {
        name: 'runtime'
      }
    },

    // æ¨¡å—è§£æ
    resolve: {
      extensions: ['.js', '.jsx', '.ts', '.tsx', '.json'],
      alias: {
        '@': path.resolve(__dirname, 'src'),
        '@components': path.resolve(__dirname, 'src/components'),
        '@utils': path.resolve(__dirname, 'src/utils'),
        '@assets': path.resolve(__dirname, 'src/assets')
      },
      // ä¼˜åŒ–æ¨¡å—æŸ¥æ‰¾
      modules: [path.resolve(__dirname, 'src'), 'node_modules']
    },

    // åŠ è½½å™¨é…ç½®
    module: {
      rules: [
        // JavaScript/TypeScript
        {
          test: /\.(js|jsx|ts|tsx)$/,
          exclude: /node_modules/,
          use: {
            loader: 'babel-loader',
            options: {
              presets: [
                ['@babel/preset-env', { useBuiltIns: 'usage', corejs: 3 }],
                '@babel/preset-react',
                '@babel/preset-typescript'
              ],
              plugins: [
                // æŒ‰éœ€åŠ è½½
                ['import', { libraryName: 'antd', style: true }]
              ],
              cacheDirectory: true
            }
          }
        },

        // CSS
        {
          test: /\.css$/,
          use: [
            isProduction ? MiniCssExtractPlugin.loader : 'style-loader',
            {
              loader: 'css-loader',
              options: {
                importLoaders: 1,
                modules: {
                  auto: true,
                  localIdentName: isProduction
                    ? '[hash:base64:8]'
                    : '[name]__[local]--[hash:base64:5]'
                }
              }
            },
            'postcss-loader'
          ]
        },

        // å›¾ç‰‡èµ„æº
        {
          test: /\.(png|jpe?g|gif|svg|webp)$/i,
          type: 'asset',
          parser: {
            dataUrlCondition: {
              maxSize: 8 * 1024 // 8KB
            }
          },
          generator: {
            filename: 'images/[name].[contenthash:8][ext]'
          }
        },

        // å­—ä½“æ–‡ä»¶
        {
          test: /\.(woff|woff2|eot|ttf|otf)$/i,
          type: 'asset/resource',
          generator: {
            filename: 'fonts/[name].[contenthash:8][ext]'
          }
        }
      ]
    },

    // æ’ä»¶é…ç½®
    plugins: [
      new HtmlWebpackPlugin({
        template: './public/index.html',
        minify: isProduction
          ? {
              removeComments: true,
              collapseWhitespace: true,
              removeRedundantAttributes: true,
              useShortDoctype: true,
              removeEmptyAttributes: true,
              removeStyleLinkTypeAttributes: true,
              keepClosingSlash: true,
              minifyJS: true,
              minifyCSS: true,
              minifyURLs: true
            }
          : false
      }),

      // CSS æå–
      isProduction &&
        new MiniCssExtractPlugin({
          filename: 'css/[name].[contenthash:8].css',
          chunkFilename: 'css/[name].[contenthash:8].chunk.css'
        }),

      // Gzip å‹ç¼©
      isProduction &&
        new CompressionPlugin({
          algorithm: 'gzip',
          test: /\.(js|css|html|svg)$/,
          threshold: 8192,
          minRatio: 0.8
        }),

      // Brotli å‹ç¼©
      isProduction &&
        new CompressionPlugin({
          filename: '[path][base].br',
          algorithm: 'brotliCompress',
          test: /\.(js|css|html|svg)$/,
          compressionOptions: {
            params: {
              [require('zlib').constants.BROTLI_PARAM_QUALITY]: 11
            }
          },
          threshold: 8192,
          minRatio: 0.8
        }),

      // PWA
      isProduction &&
        new WorkboxPlugin.GenerateSW({
          clientsClaim: true,
          skipWaiting: true,
          runtimeCaching: [
            {
              urlPattern: /^https:\/\/api\./,
              handler: 'NetworkFirst',
              options: {
                cacheName: 'api-cache',
                expiration: {
                  maxEntries: 100,
                  maxAgeSeconds: 60 * 60 * 24
                }
              }
            }
          ]
        }),

      // æ‰“åŒ…åˆ†æ
      shouldAnalyze &&
        new BundleAnalyzerPlugin({
          analyzerMode: 'static',
          openAnalyzer: true,
          reportFilename: 'bundle-report.html'
        })
    ].filter(Boolean),

    // å¼€å‘æœåŠ¡å™¨
    devServer: {
      hot: true,
      compress: true,
      historyApiFallback: true,
      static: {
        directory: path.join(__dirname, 'public')
      }
    },

    // æ€§èƒ½æç¤º
    performance: {
      maxAssetSize: 250000,
      maxEntrypointSize: 250000,
      hints: isProduction ? 'warning' : false
    },

    // Source Map
    devtool: isProduction ? 'source-map' : 'eval-cheap-module-source-map'
  };
};
```

### Webpack ä¼˜åŒ–æ’ä»¶

```javascript
// webpack-optimization-plugins.js

/**
 * è‡ªå®šä¹‰ Webpack ä¼˜åŒ–æ’ä»¶
 */
class ResourceHintsPlugin {
  constructor(options = {}) {
    this.options = {
      preload: [],
      prefetch: [],
      ...options
    };
  }

  apply(compiler) {
    compiler.hooks.compilation.tap('ResourceHintsPlugin', (compilation) => {
      compilation.hooks.htmlWebpackPluginBeforeHtmlGeneration.tapAsync(
        'ResourceHintsPlugin',
        (data, cb) => {
          // æ·»åŠ  preload èµ„æº
          this.options.preload.forEach((resource) => {
            data.assets.js.unshift(
              `<link rel="preload" href="${resource}" as="script">`
            );
          });

          // æ·»åŠ  prefetch èµ„æº
          this.options.prefetch.forEach((resource) => {
            data.assets.js.push(`<link rel="prefetch" href="${resource}">`);
          });

          cb(null, data);
        }
      );
    });
  }
}

/**
 * ä»£ç åˆ†å‰²ä¼˜åŒ–æ’ä»¶
 */
class SmartSplitChunksPlugin {
  constructor(options = {}) {
    this.options = {
      maxSize: 244 * 1024, // 244KB
      minSize: 20 * 1024, // 20KB
      ...options
    };
  }

  apply(compiler) {
    compiler.hooks.thisCompilation.tap(
      'SmartSplitChunksPlugin',
      (compilation) => {
        compilation.hooks.optimizeChunks.tap(
          'SmartSplitChunksPlugin',
          (chunks) => {
            chunks.forEach((chunk) => {
              if (chunk.size() > this.options.maxSize) {
                // å¤§æ–‡ä»¶åˆ†å‰²é€»è¾‘
                this.splitLargeChunk(chunk);
              }
            });
          }
        );
      }
    );
  }

  /**
   * åˆ†å‰²å¤§æ–‡ä»¶
   * @param {Object} chunk ä»£ç å—
   */
  splitLargeChunk(chunk) {
    // å®ç°å¤§æ–‡ä»¶åˆ†å‰²é€»è¾‘
    console.log(`Splitting large chunk: ${chunk.name} (${chunk.size()} bytes)`);
  }
}

module.exports = {
  ResourceHintsPlugin,
  SmartSplitChunksPlugin
};
```

## HTTP ç¼“å­˜ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥é…ç½®

```javascript
/**
 * HTTP ç¼“å­˜ç­–ç•¥ç®¡ç†å™¨
 */
class CacheStrategyManager {
  constructor() {
    this.strategies = new Map();
    this.initDefaultStrategies();
  }

  /**
   * åˆå§‹åŒ–é»˜è®¤ç¼“å­˜ç­–ç•¥
   */
  initDefaultStrategies() {
    // é™æ€èµ„æºç¼“å­˜ç­–ç•¥
    this.strategies.set('static', {
      pattern: /\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/,
      headers: {
        'Cache-Control': 'public, max-age=31536000, immutable', // 1å¹´
        Expires: new Date(Date.now() + 31536000000).toUTCString()
      }
    });

    // HTML æ–‡ä»¶ç¼“å­˜ç­–ç•¥
    this.strategies.set('html', {
      pattern: /\.html$/,
      headers: {
        'Cache-Control': 'no-cache, must-revalidate',
        Pragma: 'no-cache',
        Expires: '0'
      }
    });

    // API æ¥å£ç¼“å­˜ç­–ç•¥
    this.strategies.set('api', {
      pattern: /^\/api\//,
      headers: {
        'Cache-Control': 'private, max-age=300', // 5åˆ†é’Ÿ
        Vary: 'Accept-Encoding, Authorization'
      }
    });

    // å›¾ç‰‡èµ„æºç¼“å­˜ç­–ç•¥
    this.strategies.set('images', {
      pattern: /\.(png|jpg|jpeg|gif|webp|svg)$/,
      headers: {
        'Cache-Control': 'public, max-age=2592000', // 30å¤©
        Vary: 'Accept-Encoding'
      }
    });
  }

  /**
   * è·å–èµ„æºçš„ç¼“å­˜ç­–ç•¥
   * @param {string} url èµ„æºURL
   * @returns {Object} ç¼“å­˜ç­–ç•¥
   */
  getStrategy(url) {
    for (const [name, strategy] of this.strategies) {
      if (strategy.pattern.test(url)) {
        return { name, ...strategy };
      }
    }
    return null;
  }

  /**
   * æ·»åŠ è‡ªå®šä¹‰ç¼“å­˜ç­–ç•¥
   * @param {string} name ç­–ç•¥åç§°
   * @param {Object} strategy ç­–ç•¥é…ç½®
   */
  addStrategy(name, strategy) {
    this.strategies.set(name, strategy);
  }
}

/**
 * Express ä¸­é—´ä»¶ï¼šè®¾ç½®ç¼“å­˜å¤´
 * @param {Object} req è¯·æ±‚å¯¹è±¡
 * @param {Object} res å“åº”å¯¹è±¡
 * @param {Function} next ä¸‹ä¸€ä¸ªä¸­é—´ä»¶
 */
function setCacheHeaders(req, res, next) {
  const cacheManager = new CacheStrategyManager();
  const strategy = cacheManager.getStrategy(req.url);

  if (strategy) {
    Object.entries(strategy.headers).forEach(([key, value]) => {
      res.setHeader(key, value);
    });

    // æ·»åŠ  ETag æ”¯æŒ
    if (strategy.name === 'static') {
      res.setHeader('ETag', `"${generateETag(req.url)}"`);
    }
  }

  next();
}

/**
 * ç”Ÿæˆ ETag
 * @param {string} url èµ„æºURL
 * @returns {string} ETagå€¼
 */
function generateETag(url) {
  const crypto = require('crypto');
  return crypto
    .createHash('md5')
    .update(url + Date.now())
    .digest('hex');
}

module.exports = {
  CacheStrategyManager,
  setCacheHeaders
};
```

### Service Worker ç¼“å­˜

```javascript
// service-worker.js

/**
 * Service Worker ç¼“å­˜ç®¡ç†
 */
class ServiceWorkerCache {
  constructor() {
    this.CACHE_NAME = 'app-cache-v1';
    this.STATIC_CACHE = 'static-cache-v1';
    this.DYNAMIC_CACHE = 'dynamic-cache-v1';
    this.API_CACHE = 'api-cache-v1';

    this.STATIC_ASSETS = [
      '/',
      '/static/js/main.js',
      '/static/css/main.css',
      '/static/images/logo.png'
    ];
  }

  /**
   * å®‰è£… Service Worker
   */
  async install() {
    const cache = await caches.open(this.STATIC_CACHE);
    await cache.addAll(this.STATIC_ASSETS);
    console.log('Service Worker: Static assets cached');
  }

  /**
   * æ¿€æ´» Service Worker
   */
  async activate() {
    const cacheNames = await caches.keys();
    const deletePromises = cacheNames
      .filter(
        (name) =>
          name !== this.STATIC_CACHE &&
          name !== this.DYNAMIC_CACHE &&
          name !== this.API_CACHE
      )
      .map((name) => caches.delete(name));

    await Promise.all(deletePromises);
    console.log('Service Worker: Old caches cleaned');
  }

  /**
   * å¤„ç† fetch è¯·æ±‚
   * @param {Request} request è¯·æ±‚å¯¹è±¡
   * @returns {Response} å“åº”å¯¹è±¡
   */
  async handleFetch(request) {
    const url = new URL(request.url);

    // API è¯·æ±‚ç¼“å­˜ç­–ç•¥
    if (url.pathname.startsWith('/api/')) {
      return this.handleApiRequest(request);
    }

    // é™æ€èµ„æºç¼“å­˜ç­–ç•¥
    if (this.isStaticAsset(url.pathname)) {
      return this.handleStaticAsset(request);
    }

    // åŠ¨æ€å†…å®¹ç¼“å­˜ç­–ç•¥
    return this.handleDynamicContent(request);
  }

  /**
   * å¤„ç† API è¯·æ±‚
   * @param {Request} request è¯·æ±‚å¯¹è±¡
   * @returns {Response} å“åº”å¯¹è±¡
   */
  async handleApiRequest(request) {
    const cache = await caches.open(this.API_CACHE);

    try {
      // ç½‘ç»œä¼˜å…ˆç­–ç•¥
      const networkResponse = await fetch(request);

      if (networkResponse.ok) {
        // ç¼“å­˜æˆåŠŸçš„å“åº”
        cache.put(request, networkResponse.clone());
      }

      return networkResponse;
    } catch (error) {
      // ç½‘ç»œå¤±è´¥æ—¶è¿”å›ç¼“å­˜
      const cachedResponse = await cache.match(request);
      if (cachedResponse) {
        return cachedResponse;
      }

      throw error;
    }
  }

  /**
   * å¤„ç†é™æ€èµ„æº
   * @param {Request} request è¯·æ±‚å¯¹è±¡
   * @returns {Response} å“åº”å¯¹è±¡
   */
  async handleStaticAsset(request) {
    // ç¼“å­˜ä¼˜å…ˆç­–ç•¥
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }

    const networkResponse = await fetch(request);
    const cache = await caches.open(this.STATIC_CACHE);
    cache.put(request, networkResponse.clone());

    return networkResponse;
  }

  /**
   * å¤„ç†åŠ¨æ€å†…å®¹
   * @param {Request} request è¯·æ±‚å¯¹è±¡
   * @returns {Response} å“åº”å¯¹è±¡
   */
  async handleDynamicContent(request) {
    const cache = await caches.open(this.DYNAMIC_CACHE);

    try {
      const networkResponse = await fetch(request);
      cache.put(request, networkResponse.clone());
      return networkResponse;
    } catch (error) {
      const cachedResponse = await cache.match(request);
      return (
        cachedResponse ||
        new Response('Offline content not available', {
          status: 503,
          statusText: 'Service Unavailable'
        })
      );
    }
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä¸ºé™æ€èµ„æº
   * @param {string} pathname è·¯å¾„
   * @returns {boolean} æ˜¯å¦ä¸ºé™æ€èµ„æº
   */
  isStaticAsset(pathname) {
    return /\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/.test(pathname);
  }
}

// Service Worker äº‹ä»¶ç›‘å¬
const swCache = new ServiceWorkerCache();

self.addEventListener('install', (event) => {
  event.waitUntil(swCache.install());
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(swCache.activate());
  self.clients.claim();
});

self.addEventListener('fetch', (event) => {
  event.respondWith(swCache.handleFetch(event.request));
});
```

## ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½

### React ä»£ç åˆ†å‰²

```javascript
// è·¯ç”±çº§ä»£ç åˆ†å‰²
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';
import LoadingSpinner from './components/LoadingSpinner';

/**
 * æ‡’åŠ è½½ç»„ä»¶åŒ…è£…å™¨
 * @param {Function} importFunc åŠ¨æ€å¯¼å…¥å‡½æ•°
 * @param {Object} fallback åŠ è½½ä¸­çš„ç»„ä»¶
 * @returns {Component} æ‡’åŠ è½½ç»„ä»¶
 */
const lazyWithRetry = (importFunc, fallback = <LoadingSpinner />) => {
  return lazy(() =>
    importFunc().catch((error) => {
      console.error('Lazy loading failed:', error);
      // é‡è¯•æœºåˆ¶
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(importFunc());
        }, 1000);
      });
    })
  );
};

// æ‡’åŠ è½½é¡µé¢ç»„ä»¶
const HomePage = lazyWithRetry(() => import('./pages/HomePage'));
const AboutPage = lazyWithRetry(() => import('./pages/AboutPage'));
const ProductPage = lazyWithRetry(() => import('./pages/ProductPage'));
const UserProfile = lazyWithRetry(() => import('./pages/UserProfile'));

/**
 * åº”ç”¨è·¯ç”±é…ç½®
 */
function AppRoutes() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route
          path="/"
          element={<HomePage />}
        />
        <Route
          path="/about"
          element={<AboutPage />}
        />
        <Route
          path="/products/:id"
          element={<ProductPage />}
        />
        <Route
          path="/profile"
          element={<UserProfile />}
        />
      </Routes>
    </Suspense>
  );
}

/**
 * ç»„ä»¶çº§ä»£ç åˆ†å‰²
 */
const HeavyChart = lazy(() =>
  import('./components/HeavyChart').then((module) => ({
    default: module.HeavyChart
  }))
);

const DataTable = lazy(() => import('./components/DataTable'));

/**
 * æ¡ä»¶åŠ è½½ç»„ä»¶
 * @param {Object} props ç»„ä»¶å±æ€§
 */
function ConditionalComponents({ showChart, showTable }) {
  return (
    <div>
      {showChart && (
        <Suspense fallback={<div>Loading chart...</div>}>
          <HeavyChart />
        </Suspense>
      )}

      {showTable && (
        <Suspense fallback={<div>Loading table...</div>}>
          <DataTable />
        </Suspense>
      )}
    </div>
  );
}

export { AppRoutes, ConditionalComponents };
```

### åŠ¨æ€å¯¼å…¥ä¼˜åŒ–

```javascript
/**
 * æ™ºèƒ½é¢„åŠ è½½ç®¡ç†å™¨
 */
class PreloadManager {
  constructor() {
    this.preloadedModules = new Set();
    this.preloadQueue = [];
    this.isPreloading = false;
  }

  /**
   * é¢„åŠ è½½æ¨¡å—
   * @param {Function} importFunc åŠ¨æ€å¯¼å…¥å‡½æ•°
   * @param {string} moduleName æ¨¡å—åç§°
   * @returns {Promise} é¢„åŠ è½½Promise
   */
  async preloadModule(importFunc, moduleName) {
    if (this.preloadedModules.has(moduleName)) {
      return;
    }

    try {
      await importFunc();
      this.preloadedModules.add(moduleName);
      console.log(`Module preloaded: ${moduleName}`);
    } catch (error) {
      console.error(`Failed to preload module: ${moduleName}`, error);
    }
  }

  /**
   * æ‰¹é‡é¢„åŠ è½½
   * @param {Array} modules æ¨¡å—åˆ—è¡¨
   */
  async batchPreload(modules) {
    if (this.isPreloading) return;

    this.isPreloading = true;

    for (const { importFunc, name, priority = 0 } of modules) {
      this.preloadQueue.push({ importFunc, name, priority });
    }

    // æŒ‰ä¼˜å…ˆçº§æ’åº
    this.preloadQueue.sort((a, b) => b.priority - a.priority);

    // å¹¶å‘é¢„åŠ è½½ï¼ˆé™åˆ¶å¹¶å‘æ•°ï¼‰
    const concurrency = 3;
    const chunks = this.chunkArray(this.preloadQueue, concurrency);

    for (const chunk of chunks) {
      await Promise.all(
        chunk.map(({ importFunc, name }) =>
          this.preloadModule(importFunc, name)
        )
      );
    }

    this.isPreloading = false;
    this.preloadQueue = [];
  }

  /**
   * åŸºäºç”¨æˆ·è¡Œä¸ºçš„æ™ºèƒ½é¢„åŠ è½½
   * @param {string} currentRoute å½“å‰è·¯ç”±
   */
  intelligentPreload(currentRoute) {
    const preloadMap = {
      '/': [
        {
          importFunc: () => import('./pages/AboutPage'),
          name: 'AboutPage',
          priority: 1
        },
        {
          importFunc: () => import('./pages/ProductPage'),
          name: 'ProductPage',
          priority: 2
        }
      ],
      '/products': [
        {
          importFunc: () => import('./components/ProductDetail'),
          name: 'ProductDetail',
          priority: 1
        },
        {
          importFunc: () => import('./components/ReviewSection'),
          name: 'ReviewSection',
          priority: 2
        }
      ]
    };

    const modulesToPreload = preloadMap[currentRoute];
    if (modulesToPreload) {
      // å»¶è¿Ÿé¢„åŠ è½½ï¼Œé¿å…å½±å“å½“å‰é¡µé¢æ€§èƒ½
      setTimeout(() => {
        this.batchPreload(modulesToPreload);
      }, 2000);
    }
  }

  /**
   * æ•°ç»„åˆ†å—
   * @param {Array} array åŸæ•°ç»„
   * @param {number} size å—å¤§å°
   * @returns {Array} åˆ†å—åçš„æ•°ç»„
   */
  chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}

/**
 * å›¾ç‰‡æ‡’åŠ è½½Hook
 * @param {Object} options é…ç½®é€‰é¡¹
 * @returns {Object} æ‡’åŠ è½½çŠ¶æ€å’Œå¼•ç”¨
 */
function useImageLazyLoad(options = {}) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      {
        threshold: 0.1,
        rootMargin: '50px',
        ...options
      }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  const handleLoad = () => {
    setIsLoaded(true);
  };

  return {
    imgRef,
    isLoaded,
    isInView,
    handleLoad
  };
}

/**
 * æ‡’åŠ è½½å›¾ç‰‡ç»„ä»¶
 * @param {Object} props ç»„ä»¶å±æ€§
 */
function LazyImage({ src, alt, placeholder, className, ...props }) {
  const { imgRef, isLoaded, isInView, handleLoad } = useImageLazyLoad();

  return (
    <div
      ref={imgRef}
      className={className}
    >
      {isInView && (
        <>
          <img
            src={src}
            alt={alt}
            onLoad={handleLoad}
            style={{
              opacity: isLoaded ? 1 : 0,
              transition: 'opacity 0.3s ease-in-out'
            }}
            {...props}
          />
          {!isLoaded && placeholder && (
            <div className="image-placeholder">{placeholder}</div>
          )}
        </>
      )}
    </div>
  );
}

export { PreloadManager, useImageLazyLoad, LazyImage };
```

## æ€»ç»“

å‰ç«¯æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªç³»ç»Ÿæ€§å·¥ç¨‹ï¼Œéœ€è¦ä»å¤šä¸ªç»´åº¦è¿›è¡Œè€ƒè™‘ï¼š

### ğŸ¯ æ ¸å¿ƒä¼˜åŒ–ç­–ç•¥

1. **æ„å»ºä¼˜åŒ–**
   - ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
   - èµ„æºå‹ç¼©å’Œæ··æ·†
   - Tree Shaking å»é™¤æ— ç”¨ä»£ç 
   - åˆç†çš„ç¼“å­˜ç­–ç•¥

2. **ç½‘ç»œä¼˜åŒ–**
   - HTTP/2 å¤šè·¯å¤ç”¨
   - èµ„æºé¢„åŠ è½½å’Œé¢„è·å–
   - CDN åŠ é€Ÿ
   - å›¾ç‰‡æ ¼å¼ä¼˜åŒ–

3. **è¿è¡Œæ—¶ä¼˜åŒ–**
   - è™šæ‹Ÿæ»šåŠ¨
   - é˜²æŠ–å’ŒèŠ‚æµ
   - å†…å­˜æ³„æ¼é˜²æŠ¤
   - é•¿ä»»åŠ¡åˆ†ç‰‡

### ğŸ“Š æ€§èƒ½ç›‘æ§

å»ºç«‹å®Œå–„çš„æ€§èƒ½ç›‘æ§ä½“ç³»ï¼ŒæŒç»­è·Ÿè¸ªå…³é”®æŒ‡æ ‡ï¼š

- Core Web Vitals (LCP, FID, CLS)
- è‡ªå®šä¹‰ä¸šåŠ¡æŒ‡æ ‡
- é”™è¯¯ç›‘æ§å’Œå‘Šè­¦
- ç”¨æˆ·ä½“éªŒæ•°æ®æ”¶é›†

### ğŸ”§ å·¥å…·é“¾é€‰æ‹©

æ ¹æ®é¡¹ç›®ç‰¹ç‚¹é€‰æ‹©åˆé€‚çš„æ„å»ºå·¥å…·ï¼š

- **Vite**: é€‚åˆç°ä»£åŒ–é¡¹ç›®ï¼Œå¼€å‘ä½“éªŒå¥½
- **Webpack**: ç”Ÿæ€æˆç†Ÿï¼Œé…ç½®çµæ´»ï¼Œé€‚åˆå¤æ‚é¡¹ç›®
- **Rollup**: é€‚åˆåº“å¼€å‘ï¼Œæ‰“åŒ…ä½“ç§¯å°

æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦ç»“åˆå…·ä½“ä¸šåŠ¡åœºæ™¯ï¼Œåˆ¶å®šåˆé€‚çš„ä¼˜åŒ–ç­–ç•¥ï¼Œå¹¶é€šè¿‡æ•°æ®é©±åŠ¨çš„æ–¹å¼éªŒè¯ä¼˜åŒ–æ•ˆæœã€‚
